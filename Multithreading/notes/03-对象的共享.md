# 对象的共享
## 可见性 
![可见性](../../img/可见性.png)
子线程无法了解主线程是否修改了ready变量，导致其一直执行。
## 失效数据 
没有恰当同步后的结果。某个线程已经修改了共享变量，但是另外的线程仍然使用过期的数据。
- 使用`@GuardedBy("this")`来同步变量的get、set方法。
>类似与数据库中的`READ_UNCOMMITTED`隔离级别。

## 加锁与可见性 
加锁保证同步性，当一个线程对数值进行的写入，其他线程也都可见。防止读到过期数据。

## Volatile变量 
>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

### 特点
1. 保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。

2. 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

### 区别
1. 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。
2. 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。
>重排序问题
## 发布与逸出 
## 线程封闭 
## Ad-hoc线程封闭 
## 栈封闭 
## ThreadLocal类 
## 不变性 
## Final域 
## 示例：使用Volatile类型来发布不可变对象 