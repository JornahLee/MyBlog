# Synchronized与ReentrantLock区别
## 相同点
- 加锁方式同步
- 阻塞式同步
- 开销比较大

## 区别
### Synchronized
1. java语言的关键字，是原生语法层面的互斥，需要jvm实现，由编译器去保证锁的加锁和释放。
2. 锁的细度和灵活度没有那么高。
3. 在**Synchronized**优化后，性能基本差不多。
>synchronized借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。
### ReentrantLock
1. ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成
2. ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。
3. 等待可中断
4. 可实现公平锁
5. 锁可以绑定多个条件

### 公平锁和非公平锁
如果一个线程组里，能保证每个线程都能拿到锁，那么这个锁就是公平锁。相反，如果保证不了每个线程都能拿到锁，也就是存在有线程饿死，那么这个锁就是非公平锁。

优缺点对比：
在恢复一个被挂起的线程（在这是一个锁直接进来抢占，节约时间，这个锁也不需要被挂起）与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。